# Deno Hooks - Developer Guide

## For Contributors

This guide is for developers working on deno-hooks itself. If you're a user
wanting to use deno-hooks in your project, see [README.md](README.md).

## Development Setup

```bash
# Clone the repository
git clone https://github.com/TheSwanFactory/deno-hooks.git
cd deno-hooks

# Install git hooks for this repo
deno task hooks

# Run tests
deno test -A

# Run integration tests
deno task test-integration
```

## Architecture Overview

Deno Hooks has a **simple** architecture:

1. **Configuration** ([src/config.ts](src/config.ts)) - Loads from
   `deno-hooks.yml` or `deno.json`
2. **Installation** ([src/install.ts](src/install.ts)) - Generates
   self-contained shell scripts in `.git/hooks/`

That's it! No runtime execution, no complex file filtering, just simple shell
script generation.

## How It Works

When you run `deno task hooks`:

1. Reads configuration from `deno-hooks.yml` or `deno.json`
2. Creates self-contained shell scripts in `.git/hooks/` (e.g., `pre-commit`)
3. Each script contains the commands directly (no reference to deno-hooks)

When git triggers a hook (e.g., on commit):

1. Git executes `.git/hooks/pre-commit`
2. The shell script runs each command in order
3. If any command fails (exit code ≠ 0), the git operation is blocked

## CLI Features

### Installation Mode

```bash
# Interactive installation
deno run -A src/install.ts

# Skip prompts (create default config if missing)
deno run -A src/install.ts --yes

# Show detailed output
deno run -A src/install.ts --verbose

# Combine flags
deno run -A src/install.ts --yes --verbose
```

### Command Line Arguments

- `--yes` / `-y`: Skip interactive prompts (install only)
- `--verbose` / `-v`: Show detailed output
- `--help` / `-h`: Show help message

Arguments are parsed in the `parseArgs()` function.

## Project Structure

```text
deno-hooks/
├── src/
│   ├── mod.ts          # Main exports
│   ├── config.ts       # Configuration loading
│   ├── install.ts      # Hook installation & CLI
│   └── test-hook.test.ts # Unit tests
├── scripts/
│   ├── doc-coverage.ts    # Documentation coverage checker
│   ├── test-fake-repo.ts  # Integration tests
│   └── version.ts         # Version management (display, bump, tag)
├── deno-hooks.yml      # This repo's hook config
├── deno.json           # Package configuration
└── README.md           # User documentation
```

## Configuration Format

### Simple Command Lists

Hooks are just arrays of shell commands:

```yaml
hooks:
  pre-commit:
    - deno task fmt
    - deno task lint

  pre-push:
    - deno task test
```

### No More Built-in Hooks

Unlike v0.2.x, there are no built-in hooks. Users define their own tasks in
`deno.json`:

```json
{
  "tasks": {
    "fmt": "deno fmt --check",
    "lint": "deno lint",
    "test": "deno test -A"
  }
}
```

### Why This Is Better

1. **Simpler**: No complex file filtering or built-in hooks
2. **Transparent**: Generated hooks are readable shell scripts
3. **Portable**: Hooks work without deno-hooks installed
4. **Flexible**: Users can run any command
5. **Debuggable**: Easy to see what's happening

## Generated Hook Scripts

Example `.git/hooks/pre-commit`:

```bash
#!/bin/sh
# Generated by deno-hooks - DO NOT EDIT
# To update, run: deno task hooks

set -e

deno task fmt
deno task lint

echo "✓ All hooks passed"
```

Key features:

- `#!/bin/sh` - Maximum portability
- `set -e` - Fail-fast behavior
- Direct commands - No indirection
- Success message - Clear feedback

## Testing

### Unit Tests

```bash
deno test -A
```

Tests in [src/test-hook.test.ts](src/test-hook.test.ts):

- Configuration parsing
- Command validation

### Integration Tests

```bash
deno task test-integration
```

The integration test ([scripts/test-fake-repo.ts](scripts/test-fake-repo.ts)):

- Creates a temporary git repository
- Installs hooks from local source
- Tests that hooks catch formatting/lint errors
- Tests that hooks allow valid commits
- Verifies hook scripts are self-contained

**This is critical** - it ensures generated hooks work correctly!

### Pre-Push Hooks

This repo uses its own hooks:

- **pre-commit**: Runs `deno task fmt` and `deno task lint`
- **pre-push**: Runs unit tests AND integration tests

## Publishing

Publishing to JSR is automated via GitHub Actions. Use the `deno task version`
command to manage versions and releases.

### Version Management Commands

```bash
# Display current version
deno task version

# Bump version (automatically updates deno.json)
deno task version patch  # 0.3.0 -> 0.3.1
deno task version minor  # 0.3.0 -> 0.4.0
deno task version major  # 0.3.0 -> 1.0.0

# Create and push dev pre-release tag (timestamp-based, merge-safe)
deno task version dev    # 0.3.0 -> 0.3.0-dev.1734293847

# Reset from dev version to stable
deno task version reset  # 0.3.0-dev.1734293847 -> 0.3.0

# Create and push stable release tag
deno task version tag

# Show help
deno task version help
```

**Dev Versioning**: Dev releases use timestamp-based identifiers (epoch seconds)
like `0.3.0-dev.1734293847`. This ensures monotonic, merge-safe versions that
won't conflict when multiple branches create dev releases simultaneously.

### Release Workflow

#### Dev Pre-release (for testing)

Use dev releases to test JSR publication before stable releases:

1. Create dev release: `deno task version dev`
   - Generates timestamp-based version (e.g., `0.3.0-dev.1734293847`)
   - Commits, tags, and pushes automatically
2. Test the dev release:
   `deno run -A jsr:@theswanfactory/deno-hooks@0.3.0-dev.1734293847`
3. Reset to stable: `deno task version reset`
   - Removes `-dev.timestamp` suffix
   - Commits and pushes automatically

**Note**: You cannot bump versions while on a dev/prerelease version. You must
reset to stable first.

#### Stable Release

##### Option 1: Automated version bump

1. Update version: `deno task version major` (for v1.0.0)
2. Update `CHANGELOG.md` (move changes from `[Unreleased]` to new version)
3. Commit: `git commit -am "Bump version to $(deno task version)"`
4. Push: `git push`
5. Create tag: `deno task version tag`

##### Option 2: Manual version in deno.json

1. Edit `deno.json` to change version manually
2. Update `CHANGELOG.md` (move changes from `[Unreleased]` to new version)
3. Commit: `git commit -am "Bump version to X.Y.Z"`
4. Push: `git push`
5. Create tag: `deno task version tag`

The `deno task version tag` command will:

- Read the version from `deno.json`
- Verify the working directory is clean
- Check that the tag doesn't already exist
- Create an annotated git tag (e.g., `v1.0.0`)
- Push the tag to GitHub
- Trigger GitHub Actions to publish to JSR automatically

See [.github/workflows/publish.yml](.github/workflows/publish.yml).

## Import Alias Configuration

The project uses a dual setup for the `deno-hooks` import alias:

### In this repository (development)

```json
{
  "imports": {
    "deno-hooks": "./src/mod.ts"
  }
}
```

This allows developers to use `deno task hooks` which runs the local source.

### In user projects (production)

Users should configure:

```json
{
  "imports": {
    "deno-hooks": "jsr:@theswanfactory/deno-hooks@^1.0.0"
  }
}
```

This installs from JSR and gets version updates automatically.

## Implementation Details

### Configuration Parsing

The config parser expects a simple structure:

```typescript
interface Config {
  hooks: {
    [hookName: string]: string[]; // Just arrays of commands!
  };
}
```

Validation ensures:

- `hooks` is an object
- Each hook value is an array
- Each command is a non-empty string

### Hook Script Generation

The `generateHookScript()` function:

1. Takes an array of commands
2. Joins them with newlines
3. Wraps in a shell script template
4. Returns the complete script

No complex logic, just string concatenation!

### Verbose Output

The `--verbose` flag adds detailed logging:

- **Install mode**: Shows paths, file counts, hook details

This helps users debug configuration issues.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run `deno fmt` and `deno lint`
5. Run `deno test -A` and `deno task test-integration`
6. Submit a PR

## Architecture Decisions

### Why Remove Built-in Hooks?

**Old way (v0.2.x):**

```yaml
hooks:
  pre-commit:
    - id: deno-fmt
      run: deno-fmt # Built-in hook
      glob: "*.ts"
      pass_filenames: true
```

**New way (v1.0.0+):**

```yaml
hooks:
  pre-commit:
    - deno task fmt # Just a command
```

**Benefits:**

1. **Simpler codebase**: No executor.ts, files.ts, run.ts
2. **User control**: Users define behavior in deno.json tasks
3. **Transparency**: No magic file filtering
4. **Portability**: Hooks are just shell scripts
5. **Flexibility**: Can run ANY command, not just Deno tools

### Why Self-Contained Scripts?

**Old way:** `.git/hooks/pre-commit` calls `deno run -A src/run.ts`

**New way:** `.git/hooks/pre-commit` contains the commands directly

**Benefits:**

1. **Independence**: Hooks work without deno-hooks installed
2. **Speed**: No runtime overhead
3. **Debuggability**: Easy to see what runs
4. **Reliability**: No version conflicts or import issues

### Why Remove File Filtering?

**Old approach:** Complex glob patterns, pass_filenames, exclude patterns

**New approach:** Let Deno tasks handle their own files

**Benefits:**

1. **Simplicity**: No glob matching logic
2. **Correctness**: Deno tools know which files to check
3. **Performance**: Tools optimize their own file discovery
4. **Flexibility**: Users can filter in their tasks if needed

Example:

```json
{
  "tasks": {
    "fmt": "deno fmt --check", // Checks all formatted files
    "fmt:ts": "deno fmt --check src/", // Checks only src/
    "fmt:staged": "deno fmt --check $(git diff --cached --name-only --diff-filter=ACM)"
  }
}
```

## Migration from v0.2.x

This is a **breaking change**. The architecture is completely different.

### What Changed

**Removed:**

- `src/run.ts` - Runtime execution
- `src/executor.ts` - Built-in hooks
- `src/files.ts` - File filtering
- `src/hook.ts` - Type definitions
- Built-in hooks: `deno-fmt`, `deno-lint`, `deno-test`
- File patterns: `glob`, `exclude`, `pass_filenames`

**Simplified:**

- `src/config.ts` - Just parse command arrays
- `src/install.ts` - Just generate shell scripts
- `src/mod.ts` - Just export install function

**Result:** 200+ lines of code removed, vastly simpler architecture.

### Migration Guide for Users

**Before:**

```yaml
hooks:
  pre-commit:
    - id: deno-fmt
      run: deno-fmt
      glob: "*.{ts,js}"
      pass_filenames: true
```

**After:**

```yaml
hooks:
  pre-commit:
    - deno task fmt
```

And define the task:

```json
{
  "tasks": {
    "fmt": "deno fmt --check"
  }
}
```

## Resources

- **Spec**: [spec/1-tasks/01-task-specs.md](spec/1-tasks/01-task-specs.md)
- **Git Hooks**: [git-scm.com/docs/githooks](https://git-scm.com/docs/githooks)
- **JSR Package**:
  [jsr.io/@theswanfactory/deno-hooks](https://jsr.io/@theswanfactory/deno-hooks)
